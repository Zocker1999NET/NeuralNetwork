using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using NeuralNetwork.Neurons;

namespace NeuralNetwork {
	/// <summary>
	/// Represents all layered neural networks
	/// </summary>
	public abstract class LayeredNetwork : NeuralNetwork {

		/// <summary>
		/// Delegates a generation method with a configuration argument for a certain neuron type.
		/// </summary>
		/// <typeparam name="T">The specific kind of neurons.</typeparam>
		/// <param name="config">The configuration argument. Behavior depends on the given method.</param>
		/// <returns></returns>
		protected delegate T genListBoolDelegate<T>(bool config) where T : GeneralNeuron;

		protected List<InputNeuron> inputLayer = new List<InputNeuron>();
		protected List<OutputNeuron> outputLayer = new List<OutputNeuron>();

		protected LayeredNetwork(int inputCount, int outputCount, bool inputConfig, bool outputConfig) {
			addCountToList(inputCount, generateInputNeuron, inputLayer, inputConfig);
			addCountToList(outputCount, generateOutputNeuron, outputLayer, outputConfig);
		}

		/// <summary>
		/// Adds the given count of neurons generated by the given method to the given list.
		/// </summary>
		/// <typeparam name="T">The specific kind of neurons.</typeparam>
		/// <param name="count">The count of neurons this method should add to the list.</param>
		/// <param name="method">The method which is to create the neurons to add to the list.</param>
		/// <param name="l">The list the created neurons will be added to.</param>
		/// <param name="config">The configuration argument. Behavior depends on the given method.</param>
		protected void addCountToList<T>(int count, genListBoolDelegate<T> method, List<T> l, bool config = false) where T : GeneralNeuron {
			for(int c = 0; c < count; c++)
				l.Add(method(config));
		}

		/// <summary>
		/// Creates connections with random weights between both layers.
		/// </summary>
		/// <param name="output">The output neurons of the new connections.</param>
		/// <param name="input">The input neurons of the new connections.</param>
		protected void addConnections(DependentNeuron[] output, GeneralNeuron[] input) {
			foreach(var o in output)
				foreach(var i in input)
					o.AddInputConnection(i, nextRandom());
		}

		/// <summary>
		/// Generates a new input neuron this kind of network should use.
		/// </summary>
		/// <param name="config">The configuration argument. Behavior depends on the overriding method.</param>
		/// <returns>The new created neuron.</returns>
		protected abstract InputNeuron generateInputNeuron(bool config);

		/// <summary>
		/// Generates a new output neuron this kind of network should use.
		/// </summary>
		/// <param name="config">The configuration argument. Behavior depends on the overriding method.</param>
		/// <returns>The new created neuron.</returns>
		protected abstract OutputNeuron generateOutputNeuron(bool config);

		/// <summary>
		/// Returns the individual counts of all layers.
		/// </summary>
		/// <returns>The count of neurons for each layer.</returns>
		public abstract int[] GetNeuronsCounts();

		/// <summary>
		/// Returns the count of layers this network has.
		/// </summary>
		/// <returns>The count of layers.</returns>
		public int GetLayerCounts() {
			return GetNeuronsCounts().Count();
		}

		/// <summary>
		/// Returns the count of all neurons this network has.
		/// </summary>
		/// <returns>The count of all neurons.</returns>
		public int GetNeuronCount() {
			return GetNeuronsCounts().Sum();
		}

	}
}
